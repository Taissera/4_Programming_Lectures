/*
Упорядочить массивы 

Существуют разные алгоритмы, которые вы, скорее всего, будете писать в дальнейшем. Остановимся на одном из самых простых. 
Это так называемый алгоритм сортировки методом выбора, ещё его называют алгоритм сортировки методом минимакса 
или иногда просто называют методом максимального, или выбора максимального или выбора минимального и так далее. 
Узнаем, в чём особенность (суть) этого алгоритма. Есть какая-то последовательность чисел. 
Наша задача — выбрать самый первый элемент и в оставшейся части, с учётом нашей текущей позиции определить минимальный. 
После того как он найден, нужно поменять выделенный (рабочий элемент), на который сейчас указывает стрелочка, 
это 6, с единицей, являющейся для нас минимальной, в общем, выделенном куске. 
Было: 6 8 3 2 1 4 5 7 
Стало: 1 8 3 2 6 4 5 7 
Поменяли. Дальше у нас следующий шаг, который будет выбирать очередной рабочий элемент для нас. 
Это теперь 8. Мы явно указываем то, что 1 уже отсортированы к ней больше касаться 
не нужно. Дальше наша задача во всём неотсортированном кусочке выбрать снова минимальный. Поменять его местами с рабочим.
Было: 1 8 3 2 6 4 5 7 
Стало: 1 2 3 8 6 4 5 7 
В таком случае получается подмассив или кусок массива из первых двух элементов отсортирован. 
Дальше переходим к следующему элементу, снова находим минимальный, и здесь получается так, что нам ничего ни с чем менять не нужно, 
то есть, он остаётся на своей позиции. На следующем этапе переходим к следующему рабочему элементу. Снова находим минимальный, 
снова меняем их местами, таким образом, мы продолжаем до того момента, пока весь массив не будет отсортирован. 
Результат: 1 2 3 4 5 6 7 8 
На самом деле мы сами указали достаточно много действий, но в то же время они могут быть выражены тремя пунктами. 
1. Найти позицию минимального элемента в неотсортированной части массива. 
2. Произвести обмен этого значения со значением первой неотсортированной позиции. 
3. Повторять пока есть неотсортированные элементы. 
*/

/*
1) Для начала заведём массив, который будем сортировать, 
int[] arr = {1, 5, 4, 3, 2, 6, 7, 1, 1}. 
Для этого алгоритма абсолютно не принципиально, если внутри массива будут повторяющиеся элементы.

2) . На следующем этапе решим небольшую подзадачу, отвечающую за вывод данных массива на экран. Напишем отдельный метод. 
Причём сделаем это несколькими способами. Первый это метод void, назовём его PrintArray. В качестве аргумента будет приходить массив. 

3) Дальше. Получение, количество элементов (буду давать разные наименования, чтобы вы тоже потихонечку к этому привыкали) Length. 
Здесь цикл for, в котором мы пробегаем по всем элементам нашего массива. Показываем на экране. 
Можно это сделать так, чтобы вывод осуществлялся в одну строку. Напишем действие array[i] и через пробел будем указывать. 
После того как вывод окончен, выведем на экран пустую строку Console.WriteLine. 

4) Итак, PrintArray(arr), где PrintArray - это наименование нашего метода.
*/
int[] arr = {1, 5, 4, 3, 2, 6, 7, 1, 1}; 
void PrintArray(int[] array) 
{ 
    int count = array.Length;
    for (int i = 0; i < count; i++) 
        { 
        Console.Write($"{array[i]}"); 
        } 
    Console.WriteLine(); 
} 
PrintArray(arr);

/*
5) Следующий этап. Нам нужно написать метод, который будет упорядочивать наш массив. Назовём его selectionSort. 
В качестве аргумента точно таким же образом, как и в методе выше, будет приходить некий массив array. 

6) В первую очередь пробежаться по всем элементам нашего массива. Чтобы не нарушать общность, сделаем определение обращение к длине нашего массива через array.Length. 
Но здесь есть отдельная особенность, о которой мы чуть-чуть позже поговорим. 

7) На следующем этапе мы определяем позицию, на которую смотрим. Назовём её minPosition. 
И запоминаем позицию рабочего элемента, для которого мы в дальнейшем будем производить какие-то действия. 
Здесь, после того, как мы выполним, какой-то блок кода, нам потребуется поменять значение нашей минимальной позиции с найденной нами позицией.
Значит, int temporary = array. Наша рабочая оппозиция, напоминаю, что она будет вычисляться индексом i. 
Соответственно, в i позицию, мы должны будем положить элемент, который будет найден в процессе работы, 
этого пока не написанного кусочка кода. То есть, это простой обмен двух переменных местами. 
И соответственно, в эту минимальную позицию, мы кладём элемент, который был временным. 

8) Дальше наша задача — заполнить блок кода, всё, что мы здесь делаем, это ищем самый минимальный элемент. 
Как это будем делать? Мы воспользуемся циклом внутри цикла, как это было в самом начале лекции for j. 
Начальная позиция, от которой мы будем начинать эти действия, как вы помните, это кусочек массива, который был отсортирован, мы уже его не касаемся, 
а то, что нас отсортировано, начинается как раз с позиции i+1. И идём мы до последнего элемента array.Length. 

9) В этом блоке кода всё, что мы делаем — это ищем минимальный элемент. 
Чтобы это сделать, мы смотрим текущий, если он меньше того элемента, который мы предполагали на минимальной позиции, то нужно сохранить текущую позицию. 
Этот блок кода ищет максимальный элемент и здесь производится swap

10) Дальше самый важный пункт заключается в том, что если мы начинаем позицию поиска максимального от индекса i+1, 
где i меняется до максимального значения позиции нашего массива, то в этом случае мы должны будем искусственно одну единицу отнять. 
Тогда получится, что ровно это i+1 даст общее количество элементов. 

11) Вызвовем упорядочивание массива SelectionSort(arr).

*/

void SelectionSort(int[] array)
{
    for (int i = 0; i < array.Length - 1; i++) 
    { 
        int minPosition = i; 
        for (int j = i+1; j < array.Length; j++) 
        { 
            if(array[j] < array[minPosition]) minPosition = j; 
            { 
            minPosition = j;
            }  
        } 
    int temporary = array[i];
    array[i] = array[minPosition]; 
    array[minPosition] = temporary; 
    } 
}  
SelectionSort(arr); 
PrintArray(arr); 
