/*
---------------------------------------------------------------
---------------------- Создание матрицы -----------------------
---------------------------------------------------------------
*/
// string[,] table = new string[2,5];
// String.Empty
// table [0,0] table [0,1] table [0,2] table [0,4]
// table [1,0] table [1,1] table [1,2] table [1,4]

/*
table[1, 2] = "слово";
for (int rows = 0; rows < 2; rows++)
{
for (int columns = 0; columns < 5; columns++)
{
Console.WriteLine($"{table[rows, columns]}");
}
}
*/

/*
int[,] matrix = new int[3, 4];
for (int i = 0; i < 3; i++)
{
for (int j = 0; j < 4; j++)
{
Console.WriteLine($"{matrix[i, j]}	");
}
}
*/

/*
int[,] matrix = new int[3, 4];
for (int i = 0; i < 3; i++)
{
    for (int j = 0; j < 4; j++)
    {
    Console.Write($"{matrix[i, j]} ");
    }
    Console.WriteLine();
}
*/


/* У нас получилась матрица или прямоугольная таблица чисел с тремя строками и четырьмя столбцами.
int[,] matrix = new int[3, 4];
for (int i = 0; i < matrix.GetLength(O) ; i++)
{
for (int j = 0; j < matrix.GetLength(1); j++) {

Важно, что 3 и 4 (int[,] matrix = new int[3, 4]), которые определены для самого массива, можно оставить, 
потому что при инициализации массива вы всегда должны определить, сколько памяти нужно выделить. 
А вот в момент, когда вы будете работать, например, в циклах или методах, можно получить количество строк и другим способом. 
Для тройки указываем имя массива и новый функционал GetLength(o). 0 в качестве аргумента означает количество строк. 
Аналогично и для четвёрки: пишем имя массива, точку и GetLength(i). 
*/

/*
int[,] matrix = new int[3, 4];
for (int i = 0; i < matrix.GetLength(0); i++)
{
    for (int j = 0; j < matrix.GetLength(1); j++)
    {
        Console.Write($"{matrix[i, j]} ");
    }
    Console.WriteLine();
}
*/

// Заполнение матрицы случайными числами
/*
Теперь попробуем воспользоваться знаниями с предыдущих лекций и опишем метод, который будет отдельно печатать двумерную матрицу на экран и заполнять её числами. 
Итак, поехали. Учитывая тот факт, что мы плюс-минус знаем, как это делается, можем немножко схитрить. Для текущего кода сделаем обрамление в виде метода. 
Делаем отступы, чтобы всё было красиво. В качестве аргумента передаём прямоугольную таблицу чисел. Вместо matrix будем передавать сокращённое название — matr. 
Метод PrintArray в качестве аргумента принимает двумерную таблицу чисел и будет печатать её на экран. 
В качестве аргумента передаём ту матрицу, которая была определена чуть раньше. 
Чтобы код был более скомпонованным, инициализацию массива перенесём поближе к вызову печати.
*/


/*
void PrintArray(int[,] matr)
{
    for (int i = 0; i < matr.GetLength(0) ; i++)
    {
        for (int j = 0; j < matr.GetLength(1) ; j++)
        {
            Console.Write($"{matr[i, j]} ");
        }
        Console.WriteLine();
    }
}
int[,] matrix = new int[3, 4];
PrintArray(matrix);
*/

/*
Теперь опишем дополнительный метод, который будет заполнять нашу матрицу случайными числами. Здесь всё почти так же, как с одномерными массивами. 
Для i указываем matr.GetLength(o), для J — matr.GetLength(i). Затем обращаемся к конкретному элементу на позиции «итый-житый» 
и пишем через использование генератора псевдослучайных чисел. Возьмём полуинтервал от 1 до 10. 
Напоминаю, из-за круглых скобок может показаться, что это интервал (как в математике), но у нас получается именно полуинтервал.
Проверим работоспособность нашего метода. Сначала инициализируемся, убедимся, что у нас нули. 
Затем сделаем FillArray, в качестве аргумента передадим наш массив и снова распечатаем. 
А чтобы отделить нули от чисел, перед финальной распечаткой добавим Console.WriteLine().
*/

/*
void PrintArray(int[,] matr)
{
    for (int i = 0; i < matr.GetLength(0) ; i++)
    {
        for (int j = 0; j < matr.GetLength(1) ; j++)
        {
            Console.Write($"{matr[i, j]} ");
        }
        Console.WriteLine();
    }
}
void FillArray(int[,] matr)
{
    for (int i = 0; i < matr.GetLength(0) ; i++)
    {
        for (int j = 0; j < matr.GetLength(1) ; j++)
        {
            matr[i,j] = new Random().Next(1,10);    //[1; 10)
        }
    }
}
int[,] matrix = new int[3, 4];
PrintArray(matrix);
FillArray(matrix);
Console.WriteLine();
PrintArray(matrix);
*/

// Закрашивание области

int[,] pic = new int[,]
{
{0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0	},
{0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	1,	1,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0	},
{0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	1,	0,	0,	1,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0	},
{0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	1,	0,	0,	1,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0	},
{0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	1,	0,	0,	0,	1,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0	},
{0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	1,	0,	0,	0,	1,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0	},
{0,	0,	0,	0,	0,	0,	0,	0,	0,	1,	0,	0,	0,	1,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0	},
{0,	0,	0,	0,	0,	0,	0,	1,	1,	0,	0,	0,	0,	1,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0	},
{0,	0,	0,	0,	0,	1,	1,	0,	0,	0,	0,	0,	1,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0	},
{0,	0,	1,	1,	1,	0,	0,	0,	0,	0,	0,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	0,	0,	0,	0	},
{0,	0,	1,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	1,	0,	0,	0	},
{0,	0,	1,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	1,	0,	0,	0	},
{0,	0,	1,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	1,	1,	1,	1,	1,	0,	0,	0,	0	},
{0,	0,	1,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	1,	0,	0,	0	},
{0,	0,	1,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	1,	0,	0,	0	},
{0,	0,	1,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	1,	1,	1,	1,	1,	0,	0,	0,	0	},
{0,	0,	1,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	1,	0,	0,	0,	0	},
{0,	0,	1,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	1,	0,	0,	0,	0	},
{0,	0,	1,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	1,	1,	1,	1,	1,	0,	0,	0,	0,	0	},
{0,	0,	1,	1,	1,	1,	1,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	1,	0,	0,	0,	0,	0	},
{0,	0,	0,	0,	0,	0,	0,	1,	1,	1,	1,	0,	0,	0,	0,	0,	0,	0,	1,	0,	0,	0,	0,	0,	0	},
{0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	1,	1,	1,	1,	1,	1,	1,	0,	0,	0,	0,	0,	0,	0	},
{0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0	},
};

// будем искусственно печатать пробел. В противном случае мы можем распечатать плюс. PrintImage в качестве аргумента передаём массив, который содержит в себе картинку.
/* void PrintImage(int[,] image)
{
for (int i = 0; i < image.GetLength(0) ; i++)
{
for (int j = 0; j < image.GetLength(1); j++) {
if(image[i,j] == 0) Console.Write($" "); else Console.Write($"+");
}
Console.WriteLine();
}
}
PrintImage(pic);
*/

/*
Дальше предлагаю описать метод, который будет закрашивать картинку. По аналогии назовём его Filllmage. 
А в качестве аргумента я укажу позицию строки и пикселя, с которого мы должны будем начать закраску. 
Дальше я проверяю условие: если текущий пиксель (pic) с указанной позицией (row, col) равен нулю (то есть не закрашен), я буду его красить единичкой. 
А дальше вызову Filllmage. И здесь мы определяем правило — что за чем идёт. 
Сначала поднимаемся на строчку выше (row-1, col), потом идём влево (row, col-1), потом вниз (row+1, col), потом вправо (row, col+1). 
*/

void PrintImage(int[,] image)
{
    for (int i = 0; i < image.GetLength(0) ; i++)
    {
        for (int j = 0; j < image.GetLength(1); j++)
        {
            if(image[i,j] == 0) Console.Write($" "); else Console.Write($"+");
        }
        Console.WriteLine();
    }
}
void FillImage(int row, int col)
{
    if (pic[row, col] == 0)
    {
        pic[row, col] = 1;
        FillImage(row - 1, col);
        FillImage(row, col - 1);
        FillImage(row + 1, col);
        FillImage(row, col + 1);
    }
}
PrintImage(pic);
FillImage(13, 13);
PrintImage(pic);
